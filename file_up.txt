# PURPOSE: READ FROM ONE FILE AND CONVERT ITS LOWER-CASE INTO UPPER-CASE 
#          AND WRITE THAT INTO ANOTHER FILE

.SECTION .DATA
#CONSTANTS#
.EQU SYS_OPEN, 5
.EQU SYS_WRITE, 4
.EQU SYS_READ, 3
.EQU SYS_CLOSE, 6
.EQU SYS_EXIT, 1


# /USR/INCLUDE/ASM/FCNTL.H FOR REFERENCES
.EQU O_RDONLY, 0
.EQU O_CREAT_WRONLY_TRUNC, 03101

# STANDARD FILE DESCRIPTORS
.EQU STDIN, 0 # INPUT
.EQU STDOUT, 1 # OUTPUT
.EQU STDERR, 2 # ERROR

.EQU LINUX_SYSCALL, 0X80 # SYSCALL INTERRUPT 

.EQU END_OF_FILE, 0 # RETURN VALUE OF READ WHICH MEAN WE'VE HIT THE EOF
.EQU NUMBER_ARGUMENTS, 2

# THINGS THAT DON'T NEED INITIALIZATION BUT ONLY RESERVED SPACE; IN THE MEMORY
.SECTION .BSS
# BUFFER - WHERE THE DATA IS LOADED INTO FROM THE DATA FILE AND WRITTEN FROM 
# INTO THE OUTPUT FILE
.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE # CREATING A BUFFER OF SIZE 500 ( BUFFER_SIZE->500 )

.SECTION .TEXT

.EQU ST_SIZE_RESERVE, 8
.EQU ST_FD_IN, -4
.EQU ST_FD_OUT, -8
.EQU ST_ARGC, 0 
.EQU ST_ARGV_0, 4
.EQU ST_ARGV_1, 8
.EQU ST_ARGV_2, 12

.GLOBL _START

_START:
# SAVE THE STACK POINTER
MOVL %ESP, %EBP

# ALLOCATE SPACE FOR THE FILE DESCRIPTORS ON THE STACK
SUBL $ST_SIZE_RESERVE, %ESP # INCREASES THE SIZE OF THE STACK FRAME

OPEN_FILES:
OPEN_FD_IN:
# OPEN INPUT FILE
# OPEN SYSCALL : SYSCALL NUMBER 5 FROM THE DOCS HTTPS://WWW.CHROMIUM.ORG/CHROMIUM-OS/DEVELOPER-LIBRARY/REFERENCE/LINUX-CONSTANTS/SYSCALLS/#I686_5
  MOVL $SYS_OPEN, %EAX
# INPUT FILENAME INTO %EBX
  MOVL ST_ARGV_1(%EBP) , %EBX # THIS IS EQUIVALENT TO | MOVL VALUEOF %EBP + OFFSET(ST_ARGV_1), %EBX

# READ-ONLY FLAG
MOVL $O_RDONLY, %ECX

MOVL $0666, %EDX

# CALL INT SYSCALL
INT $LINUX_SYSCALL

STORE_FD_IN:
  MOVL %EAX, ST_FD_IN(%EBP)

OPEN_FD_OUT:

MOVL $SYS_OPEN, %EAX

MOVL ST_ARGV_2(%EBP),%EBX # OUTPUT FILNAME INTO %EBX

MOVL $O_CREAT_WRONLY_TRUNC, %ECX

MOVL $0666, %EDX # MODE FOR NEW FILE (IF IT'S CREATED)

INT $LINUX_SYSCALL # INTERRUPT SYSCALL

STORE_FD_OUT:
  MOVL %EAX, ST_FD_OUT(%EBP)

READ_LOOP_BEGIN:
  MOVL $SYS_READ, %EAX # READ IN A BLOCK FROM THE INPUT FILE

  MOVL ST_FD_IN(%EBP), %EBX # GET THE INPUT FILE DESCRIPTOR
 
  MOVL $BUFFER_DATA, %ECX # THE LOCATION TO READ INTO

  MOVL $BUFFER_SIZE, %EDX # THE SIZE OF THE BUFFER

  INT $LINUX_SYSCALL # INTERRUPT SYSCALL

  CMPL $END_OF_FILE, %EAX  # CHECKING IF WE'VE REACHED THE EOF

  JLE END_LOOP

CONTINUE_READ_LOOP:
  PUSH $BUFFER_DATA # LOCATION OF BUFFER
  PUSH %EAX # SIZE OF BUFFER
  
  CALL CONVERT_TO_UPPER

  POP %EAX # GET THE SIZE BACK
  ADDL $4, %ESP # RESTORE %ESP

## WRITE THE BLOCK TO THE OUTPUT FILE

  MOVL %EAX, %EDX # SIZE OF THE BUFFER
  MOVL $SYS_WRITE, %EAX # WRITE MODE

  MOVL ST_FD_OUT(%EBP), %EBX
  MOVL $BUFFER_DATA, %ECX # LOCATION OF THE BUFFER INTO %ECX
  INT $LINUX_SYSCALL # INTERRUPT SYSCALL

## CONTINUE THE LOOP
  JMP READ_LOOP_BEGIN

END_LOOP:
## CLOSE FILES
  MOVL $SYS_CLOSE, %EAX
  MOVL ST_FD_OUT(%EBP), %EBX
  INT $LINUX_SYSCALL # INTERRUPT SYSCALL

  MOVL $SYS_CLOSE, %EAX
  MOVL ST_FD_IN(%EBP), %EBX
  INT $LINUX_SYSCALL
  MOVL $SYS_EXIT, %EAX
  MOVL $0, %EBX
  INT $LINUX_SYSCALL


## PURPOSE: CONVERSION TO UPPPER CASE FOR A BLOCK
## INPUT: THE FIRST PARAMETER IS THE LOCATION OF THE BLOCK OF MEMORY TO CONVERT
##        THE SECOND PARAMETER IS THE LENGTH OF THAT BUFFER
##
## OUTPUT: OVERWRITES THE CURRENT BUFFER WITH THE UPPER-CASIFIED VERSION
## VARIABLES: %EAX - BEGINING OF THE BUFFER
##            %EBX - LENGTH OF BUFFER
##            %EDI - CURRENT BUFFER OFFSET
##            %CL - CURRENT BYTE BEING EXAMINED (FIRST PART OF %ECX REGISTER | LOWER PART)

## CONSTANTS
.EQU LOWERCASE_A, 'A' # LOWER BOUNDARY OF OUR SEARCH

.EQU LOWERCASE_Z, 'Z' # UPPER BOUNDARY OF OUR SEARCH

.EQU UPPER_CONVERSION, 'A' - 'A'

## STACK STUFFS

.EQU ST_BUFFER_LEN, 8 # LENGTH OF BUFFER
.EQU ST_BUFFER, 12 # ACTUAL BUFFER

CONVERT_TO_UPPER:
  PUSH %EBP
  MOVL %ESP, %EBP

## SETTING UP VARIABLES
  MOVL ST_BUFFER(%EBP), %EAX
  MOVL ST_BUFFER_LEN(%EBP), %EBX
  MOVL $0, %EDI

  CMPL $0, %EBX # IF A BUFFER WITH 0 LENGTH WAS GIVEN
  JE END_CONVERT_LOOP # EXIT THE CONVERSION LOOP

CONVERT_LOOP:
  MOVB (%EAX,%EDI,1), %CL # MOVB MOVES A SINGLE BYTE

# GO TO THE NEXT BYTE UNLESS IT IS BETWEEN 'A' AND 'Z'
  CMPB $LOWERCASE_A, %CL
  JB NEXT_BYTE

  CMPB $LOWERCASE_Z, %CL
  JA NEXT_BYTE

# OTHERWISE CONVERT  THE BYTE TO UPPERCASE
  ADDB $UPPER_CONVERSION, %CL 
# AND STORE IT BACK
  MOVB %CL, (%EAX,%EDI,1)

NEXT_BYTE:
  INCL %EDI # INCREMENT THE BUFFER OFFSET (KINDA LIKE INDEX)
  CMPL %EBX, %EDI # CHECKING IF WE'VE REACHED THE END | IF INDEX == LENGTH OF BUFFER

  JNE CONVERT_LOOP # RE_RUN THE LOOP IF NOT

END_CONVERT_LOOP:
  MOVL %EBP, %ESP
  POP %EBP
  RET
